<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>坦克大战 - 低渲染版</title>
  <style>
  :root{--cols:15;--rows:15}
    body{background:#111;color:#eee;font-family:sans-serif;margin:16px}
    .container{display:flex;gap:16px;align-items:flex-start}
  .grid{display:grid;grid-template-columns:repeat(var(--cols),36px);grid-template-rows:repeat(var(--rows),36px);gap:3px;background:#222;padding:8px;border-radius:6px}
  .cell{width:36px;height:36px;background:#333;border-radius:4px;display:flex;align-items:center;justify-content:center;font-size:14px;position:relative;overflow:hidden}
  .cell .head{position:absolute;width:10px;height:10px;background:#2196f3;border-radius:2px;transform:translate(-50%,-50%)}
  .cell .head.dir-up{left:50%;top:12%}
  .cell .head.dir-down{left:50%;top:88%}
  .cell .head.dir-left{left:12%;top:50%}
  .cell .head.dir-right{left:88%;top:50%}
  .cell .enemy-head{position:absolute;width:10px;height:10px;background:#9c27b0;border-radius:2px;transform:translate(-50%,-50%)}
  .cell .enemy-head.dir-up{left:50%;top:12%}
  .cell .enemy-head.dir-down{left:50%;top:88%}
  .cell .enemy-head.dir-left{left:12%;top:50%}
  .cell .enemy-head.dir-right{left:88%;top:50%}
    .tank{background:#2e7d32}
    .target{background:#c62828}
    .bullet{background:#ffd54f}
    .enemy-bullet{background:#4fc3f7}
    .cell .trail{position:absolute;left:0;top:0;width:100%;height:100%;border-radius:4px;pointer-events:none}
    .cell .trail.player{background:rgba(255,215,0,0.22)}
    .cell .trail.enemy{background:rgba(255,80,80,0.22)}
    .hud{min-width:180px;display:none;}
    button{padding:6px 8px;border-radius:4px;border:none;background:#444;color:#fff}
    .small{font-size:13px;color:#ccc}
  .big-btn{width:72px;height:72px;border-radius:13.5px;font-size:27px;background:rgba(255,255,255,0.10);color:#fff;border:1.5px solid rgba(255,255,255,0.10)}
  .big-fire{width:126px;height:126px;border-radius:63px;font-size:30px;background:#d32f2f;color:#fff;border:none}
  </style>
</head>
<body>
  <h3>坦克大战（低渲染版）</h3>
  <div style="width:100%;display:flex;justify-content:center;margin-bottom:24px;">
    <div id="grid" class="grid" aria-label="游戏网格"></div>
  </div>
  <!-- 网格下方的信息区域 -->
  <div style="width:100%;display:flex;justify-content:center;margin-bottom:12px;">
    <div style="text-align:center;background:rgba(34,34,34,0.9);padding:10px;border-radius:8px;max-width:590px;">
      <div>分数: <span id="score-bottom">0</span> 命数: <span id="lives-bottom">3</span></div>
      <div style="margin:5px 0;">
        <button id="spawn-bottom">立刻生成目标</button>
        <button id="reset-bottom">重置游戏</button>
      </div>
      <div class="small">WSAD: 移动 · 空格: 开火</div>
      <div class="small" style="margin-top:5px;">说明：界面只在状态变化时更新，适合低性能显卡。</div>
    </div>
  </div>

    <!-- 大按钮：左下角方向控制（四向） 与 右下角开火按钮 -->
    <div class="touch-left" aria-hidden="false" style="position:fixed;left:12px;bottom:12px;z-index:999;display:flex;flex-direction:column;gap:16px;">
      <div style="display:flex;justify-content:center">
        <button class="big-btn tc" data-action="up">↑</button>
      </div>
      <div style="display:flex;gap:16px;justify-content:center">
        <button class="big-btn tc" data-action="left">←</button>
        <button class="big-btn tc" data-action="down">↓</button>
        <button class="big-btn tc" data-action="right">→</button>
      </div>
    </div>
    <div class="touch-right" aria-hidden="false" style="position:fixed;right:24px;bottom:24px;z-index:999;">
      <button class="big-fire" id="btn-fire">开火</button>
    </div>
    
  <script>
  // 网格尺寸
  const COLS = 15, ROWS = 15;
    const gridEl = document.getElementById('grid');
    const scoreEl = document.getElementById('score-bottom');
    const spawnBtn = document.getElementById('spawn-bottom');
    const resetBtn = document.getElementById('reset-bottom');

    // 状态
  let tank = {x: Math.floor(COLS/2), y: ROWS-1, dir: 'up'}; // dir: 'up'|'down'|'left'|'right'
    let bullets = []; // 每个为 {x,y,from} from: 'player' | 'enemy'
    let enemies = []; // 每个为 {x,y,dir,moveTimer,shootTimer}
    let score = 0;
    let lives = 3; // 玩家生命值
    let isPlayerAlive = true; // 玩家是否存活
    let respawnTimer = null; // 复活定时器
  // 轨迹映射：key = `${x},${y}` -> {player: n, enemy: n}
  let trailCounts = {};
  
  // 敌人生成计时器
  let enemySpawnTimer = null;
  let totalEnemiesSpawned = 0;
  
  // 获取UI元素引用
  const livesEl = document.getElementById('lives-bottom');

    // 初始化 DOM 单元格（静态创建）
    const cells = [];
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        const div = document.createElement('div');
        div.className = 'cell';
        div.dataset.x = c; div.dataset.y = r;
        gridEl.appendChild(div);
        cells.push(div);
      }
    }

    function coordToIndex(x,y){ return y*COLS + x; }

    // 仅在状态变化时更新相关单元格（尽量少修改 DOM）
    function renderCell(x,y){
      const el = cells[coordToIndex(x,y)];
  el.className = 'cell';
  // 清除旧节点（例如 head）
  while(el.firstChild) el.removeChild(el.firstChild);
  el.textContent = '';
      // 敌人优先级高于坦克
      const enemy = enemies.find(t=>t.x===x && t.y===y);
      if (enemy){ 
        el.classList.add('target'); 
        // 添加敌人的前方方向指示（紫色点）
        const head = document.createElement('div');
        head.className = 'enemy-head ' + ('dir-' + enemy.dir);
        el.appendChild(head);
        return; 
      }
      const bullet = bullets.find(b=>b.x===x && b.y===y);
      if (bullet){ 
        if (bullet.from === 'enemy') {
          el.classList.add('enemy-bullet');
        } else {
          el.classList.add('bullet');
        }
        return; 
      }
      // 轨迹覆盖（优先于坦克显示，让用户清楚方向）
      const key = x + ',' + y;
      const tc = trailCounts[key];
      if (tc && (tc.player > 0 || tc.enemy > 0)){
        if (tc.enemy > 0){ const trail = document.createElement('div'); trail.className = 'trail enemy'; el.appendChild(trail); return; }
        if (tc.player > 0){ const trail = document.createElement('div'); trail.className = 'trail player'; el.appendChild(trail); return; }
      }
      if (tank.x===x && tank.y===y && isPlayerAlive){
        el.classList.add('tank');
        const head = document.createElement('div');
        head.className = 'head ' + ('dir-' + tank.dir);
        el.appendChild(head);
        return;
      }
    }

    function renderAll(){
      // 渲染每个格子（225 次微更新，仍比连续渲染轻，但会稍重）
      for (let y=0;y<ROWS;y++) for (let x=0;x<COLS;x++) {
        const el = cells[coordToIndex(x,y)];
        while(el.firstChild) el.removeChild(el.firstChild);
        renderCell(x,y);
      }
      scoreEl.textContent = String(score);
      if (livesEl) livesEl.textContent = String(lives);
      
      // 检查胜利条件：击中10个敌人坦克时胜利
      if (score >= 10) {
        setTimeout(()=> {
          alert('恭喜你赢了！击中了 '+score+' 个敌人坦克');
          resetGame();
        }, 10);
      }
    }

    // 核心动作：移动坦克
    function moveTank(dx,dy){
      // 如果玩家不存活，则不能移动
      if (!isPlayerAlive) return;
      
      // 先设置朝向
      if (dx===1) tank.dir='right';
      else if (dx===-1) tank.dir='left';
      else if (dy===-1) tank.dir='up';
      else if (dy===1) tank.dir='down';
      const nx = Math.max(0, Math.min(COLS-1, tank.x + dx));
      const ny = Math.max(0, Math.min(ROWS-1, tank.y + dy));
      if (nx===tank.x && ny===tank.y){
        // 方向改变但位置不变，仍要更新当前格以刷新车头
        renderCell(tank.x, tank.y);
        return;
      }
      const prev = {x:tank.x,y:tank.y};
      tank.x = nx; tank.y = ny;
      renderCell(prev.x, prev.y);
      renderCell(tank.x, tank.y);
    }

    // 发射子弹（立刻推进一格并检测命中）
    function shoot(){
      // 如果玩家不存活，则不能射击
      if (!isPlayerAlive) return;
      
      // 根据 tank.dir 生成子弹并沿方向推进直到命中或出界
      let b = {x:tank.x,y:tank.y, from: 'player'};
      const step = (d)=>{
        switch(d){
          case 'up': return {x:b.x,y:b.y-1};
          case 'down': return {x:b.x,y:b.y+1};
          case 'left': return {x:b.x-1,y:b.y};
          case 'right': return {x:b.x+1,y:b.y};
        }
      };
      // 计算轨迹路径并短暂显示
      const path = [];
      while(true){
        b = step(tank.dir);
        if (!b) return;
        // 出界
  if (b.x<0||b.x>=COLS||b.y<0||b.y>=ROWS) { showTrail(path); renderAll(); return; }
        path.push({x:b.x,y:b.y});
        const hitIndex = enemies.findIndex(t=>t.x===b.x && t.y===b.y);
        if (hitIndex>=0){
          const hitEnemy = enemies[hitIndex];
          if (hitEnemy.moveTimer) clearTimeout(hitEnemy.moveTimer);
          if (hitEnemy.shootTimer) clearTimeout(hitEnemy.shootTimer);
          enemies.splice(hitIndex,1);
          score++;
          scoreEl.textContent = String(score);
          // 显示轨迹并在 500ms 后移除
          showTrail(path,'player');
          renderAll();
          return;
        }
        // 继续下一个格
      }
    }

    function showTrail(path, type='player'){
      const keys = [];
      for (const p of path){
        const key = p.x + ',' + p.y;
        if (!trailCounts[key]) trailCounts[key] = {player:0, enemy:0};
        trailCounts[key][type] = (trailCounts[key][type] || 0) + 1;
        keys.push(key);
        renderCell(p.x,p.y);
      }
      setTimeout(()=>{
        for (const key of keys){
          if (!trailCounts[key]) continue;
          trailCounts[key][type] = Math.max(0, (trailCounts[key][type]||0)-1);
          const [x,y] = key.split(',').map(Number);
          renderCell(x,y);
        }
      }, 500);
    }

    // 随机生成目标
    function spawnTarget(){
      if (enemies.length >= 10) return; // 最多生成10个
      
      const attempts = 200;
      for (let i=0;i<attempts;i++){
        const x = Math.floor(Math.random()*COLS);
        const y = Math.floor(Math.random()*ROWS);
        if (x===tank.x && y===tank.y) continue;
        if (enemies.some(t=>t.x===x && t.y===y)) continue;
        // 随机选择一个方向
        const dirs = ['up', 'down', 'left', 'right'];
        const dir = dirs[Math.floor(Math.random() * dirs.length)];
        const enemy = {x, y, dir, moveTimer: null, shootTimer: null};
        enemies.push(enemy);
        renderCell(x,y);
        scheduleEnemyActions(enemy);
        totalEnemiesSpawned++;
        return;
      }
    }

    function scheduleEnemyActions(enemy){
      // 确保没有重复的定时器
      if (enemy.moveTimer) clearTimeout(enemy.moveTimer);
      if (enemy.shootTimer) clearTimeout(enemy.shootTimer);
      
      // 安排敌人的移动
      const scheduleMove = () => {
        if (!enemies.includes(enemy)) return;
        moveEnemy(enemy);
        enemy.moveTimer = setTimeout(scheduleMove, 1000 + Math.floor(Math.random()*1000));
      };
      enemy.moveTimer = setTimeout(scheduleMove, 1000 + Math.floor(Math.random()*1000)); // 1-2秒随机移动一次
      
      // 安排敌人的射击
      const scheduleShoot = () => {
        if (!enemies.includes(enemy)) return;
        enemyShoot(enemy);
        enemy.shootTimer = setTimeout(scheduleShoot, 2000 + Math.floor(Math.random()*2000));
      };
      enemy.shootTimer = setTimeout(scheduleShoot, 2000 + Math.floor(Math.random()*2000)); // 2-4秒随机射击一次
    }

    function moveEnemy(enemy) {
      // 50%的概率选择移动，50%的概率转动方向
      if (Math.random() < 0.5) {
        // 转动方向
        const dirs = ['up', 'down', 'left', 'right'];
        enemy.dir = dirs[Math.floor(Math.random() * dirs.length)];
        renderCell(enemy.x, enemy.y);
      } else {
        // 向前移动
        let nx = enemy.x;
        let ny = enemy.y;
        
        switch(enemy.dir) {
          case 'up': ny--; break;
          case 'down': ny++; break;
          case 'left': nx--; break;
          case 'right': nx++; break;
        }
        
        // 检查边界和碰撞
        if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS && 
            !(nx === tank.x && ny === tank.y) && 
            !enemies.some(e => e !== enemy && e.x === nx && e.y === ny)) {
          const prev = {x: enemy.x, y: enemy.y};
          enemy.x = nx;
          enemy.y = ny;
          renderCell(prev.x, prev.y);
          renderCell(enemy.x, enemy.y);
        }
      }
    }

    function enemyShoot(enemy){
      // 敌人只能向前方发射子弹
      let b = {x:enemy.x, y:enemy.y, from: 'enemy'};
      const path = [];
      const step = (d)=>{
        switch(d){
          case 'up': return {x:b.x,y:b.y-1};
          case 'down': return {x:b.x,y:b.y+1};
          case 'left': return {x:b.x-1,y:b.y};
          case 'right': return {x:b.x+1,y:b.y};
        }
      };
      
      // 只朝当前方向射击
      let nextPos = step(enemy.dir);
      if (!nextPos) return;
      
      while(true){
        b = nextPos;
        if (b.x<0||b.x>=COLS||b.y<0||b.y>=ROWS){ showTrail(path,'enemy'); renderAll(); return; }
        path.push({x:b.x,y:b.y});
        // 击中玩家?
        if (b.x===tank.x && b.y===tank.y && isPlayerAlive){
          lives--; // 减少生命值
          isPlayerAlive = false; // 玩家死亡
          showTrail(path,'enemy'); renderAll();
          
          // 清除可能存在的复活定时器
          if (respawnTimer) clearTimeout(respawnTimer);
          
          // 设置0.5秒后复活
          respawnTimer = setTimeout(() => {
            tank.x = Math.floor(COLS/2);
            tank.y = ROWS-1;
            tank.dir = 'up';
            isPlayerAlive = true;
            renderAll();
          }, 500);
          
          if (lives <= 0) {
            setTimeout(()=>{ 
              alert('游戏结束！最终得分: ' + score); 
              resetGame();
            },10);
          }
          return;
        }
        // 击中其他敌人
        const hitIdx = enemies.findIndex(t=>t.x===b.x && t.y===b.y);
        if (hitIdx>=0){
          const hitEnemy = enemies[hitIdx];
          if (hitEnemy.moveTimer) clearTimeout(hitEnemy.moveTimer);
          if (hitEnemy.shootTimer) clearTimeout(hitEnemy.shootTimer);
          enemies.splice(hitIdx,1);
          showTrail(path,'enemy'); 
          renderAll(); 
          return;
        }
        
        // 敌人子弹继续向前直到击中物体或出界
        nextPos = step(enemy.dir);
        if (!nextPos) { showTrail(path,'enemy'); renderAll(); return; }
      }
    }

    // 键盘处理（按键触发离散更新）
    window.addEventListener('keydown',(e)=>{
      // 如果玩家不存活，则不能操作
      if (!isPlayerAlive) return;
      
      const k = e.key.toLowerCase();
      if (k === 'w') moveTank(0,-1);
      else if (k === 's') moveTank(0,1);
      else if (k === 'a') moveTank(-1,0);
      else if (k === 'd') moveTank(1,0);
      else if (e.code === 'Space' || e.key === ' ') shoot();
    });

    // 控件
    spawnBtn.addEventListener('click', ()=>{ spawnTarget(); });
    
    function resetGame() {
      // 清除所有定时器
      for (const enemy of enemies) {
        if (enemy.moveTimer) clearTimeout(enemy.moveTimer);
        if (enemy.shootTimer) clearTimeout(enemy.shootTimer);
      }
      
      if (enemySpawnTimer) clearInterval(enemySpawnTimer);
      if (respawnTimer) clearTimeout(respawnTimer);
      
      enemies = [];
      bullets = [];
      score = 0;
      lives = 3; // 重置生命值
      isPlayerAlive = true; // 重置玩家状态
      tank = {x: Math.floor(COLS/2), y: ROWS-1, dir: 'up'};
      trailCounts = {};
      totalEnemiesSpawned = 0;
      
      scoreEl.textContent = '0';
      if (livesEl) livesEl.textContent = '3';
      
      // 重新开始敌人生成计时器
      startEnemySpawning();
      
      // 初始渲染与预生成目标
      for (let i=0;i<5;i++) spawnTarget();
      renderAll();
    }
    
    resetBtn.addEventListener('click', resetGame);

    // touch / tablet controls
    document.querySelectorAll('.tc').forEach(b=>{
      b.addEventListener('click', ()=>{
        // 如果玩家不存活，则不能操作
        if (!isPlayerAlive) return;
        
        const a = b.dataset.action;
        if (a === 'up') moveTank(0,-1);
        else if (a === 'down') moveTank(0,1);
        else if (a === 'left') moveTank(-1,0);
        else if (a === 'right') moveTank(1,0);
      });
    });
    
    const fireBtn = document.getElementById('btn-fire');
    if (fireBtn) fireBtn.addEventListener('click', ()=>{
      // 如果玩家不存活，则不能射击
      if (!isPlayerAlive) return;
      shoot();
    });

    // 开始敌人生成计时器
    function startEnemySpawning() {
      if (enemySpawnTimer) clearInterval(enemySpawnTimer);
      enemySpawnTimer = setInterval(() => {
        if (enemies.length < 10) {
          spawnTarget();
        }
      }, 6000); // 每6秒生成一个敌人
    }
    
    // 初始渲染与预生成目标
    startEnemySpawning();
    for (let i=0;i<5;i++) spawnTarget();
    renderAll();

  </script>
</body>
</html>