<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <!-- 页面元信息 -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>迷宫炸弹游戏</title>
    
    <!-- 页面样式 -->
    <style>
        /* 页面整体布局样式 */
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            touch-action: manipulation; /* 防止触摸时的默认行为 */
            margin: 0;
            padding: 0;
        }
        
        /* 标题样式 */
        h1 {
            margin: 10px 0;
        }
        
        /* 迷宫容器样式 */
        #maze-container {
            display: flex;
            justify-content: center;
            margin: 10px;
            width: 100%;
            max-width: 500px;
        }
        
        /* 迷宫画布样式 */
        #mazeCanvas {
            border: 2px solid #333;
            background-color: white;
            width: 100%;
            max-width: 500px;
            aspect-ratio: 1 / 1;
        }
        
        /* 控制按钮容器样式 */
        #controls {
            margin: 10px;
        }
        
        /* 按钮样式 */
        button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        /* 按钮悬停效果 */
        button:hover {
            background-color: #45a049;
        }
        
        /* 游戏说明样式 */
        #instructions {
            margin: 10px;
            text-align: center;
            max-width: 500px;
        }
        
        /* 移动端控制按钮容器 */
        #mobile-controls {
            position: fixed;
            bottom: 20px;
            width: 100%;
            display: none;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            pointer-events: none; /* 防止容器拦截点击事件 */
            z-index: 1000; /* 确保按钮在最上层 */
        }
        
        /* 方向键容器 */
        #d-pad {
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: auto; /* 恢复子元素的点击事件 */
        }
        
        /* 方向键行 */
        .d-pad-row {
            display: flex;
        }
        
        /* 控制按钮样式 */
        .control-btn {
            width: 60px;
            height: 60px;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 5px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid white;
            border-radius: 10px;
            user-select: none;
            -webkit-user-select: none; /* Safari兼容性 */
            cursor: pointer;
            pointer-events: auto; /* 确保按钮能接收点击事件 */
            touch-action: manipulation; /* 优化触摸体验 */
        }
        
        /* 控制按钮按下效果 */
        .control-btn:active {
            background-color: rgba(100, 100, 100, 0.9);
        }
        
        /* 炸弹按钮样式 */
        #bomb-btn {
            width: 80px;
            height: 80px;
            font-size: 30px;
            border-radius: 50%;
            pointer-events: auto; /* 确保按钮能接收点击事件 */
        }
    </style>
</head>
<body>
    <!-- 页面标题 -->
    <h1>迷宫炸弹游戏</h1>
    
    <!-- 游戏说明 -->
    <div id="instructions">
        <p>方向键（↑ ↓ ← →）控制移动，躲避敌人，Ctrl键放炸弹</p>
    </div>
    
    <!-- 迷宫显示容器 -->
    <div id="maze-container">
        <canvas id="mazeCanvas" width="500" height="500"></canvas>
    </div>
    
    <!-- 控制按钮区域 -->
    <div id="controls">
        <button onclick="generateMaze()">生成新迷宫</button>
    </div>

    <!-- 添加平板控制按钮 -->
    <div id="mobile-controls">
        <div id="d-pad">
            <button id="up" class="control-btn">&#8593;</button>
            <div class="d-pad-row">
                <button id="left" class="control-btn">&#8592;</button>
                <button id="right" class="control-btn">&#8594;</button>
            </div>
            <button id="down" class="control-btn">&#8595;</button>
        </div>
        <button id="bomb-btn" class="control-btn">💣</button>
    </div>

    <!-- JavaScript 脚本 -->
    <script>
        // 获取画布元素和绘图上下文
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        
        // 迷宫配置参数
        let cellSize = 20;  // 每个单元格的像素大小
        let rows, cols;     // 迷宫行列数（将在adjustCanvasSize中初始化）
        
        // 玩家配置参数
        let playerSize = cellSize - 2; // 玩家方块大小（将在adjustCanvasSize中初始化）
        let player = {
            row: 0,      // 玩家初始行位置
            col: 1,      // 玩家初始列位置
            x: 0,        // 玩家实际x坐标
            y: 0         // 玩家实际y坐标
        };
        
        // 敌人数组
        let enemies = [];
        
        // 炸弹数组
        let bombs = [];
        
        // 玩家移动计数器（用于控制敌人移动频率）
        let playerMoveCount = 0;
        
        // 自动移动敌人的时间间隔ID
        let enemyMoveInterval = null;
        
        // 起点位置记录
        const startPosition = {
            row: 0,
            col: 1
        };
        
        // 初始化迷宫数组
        let maze = [];
        
        /**
         * 初始化迷宫数组
         * 创建一个二维数组，初始时所有单元格都设置为墙体（值为1）
         */
        function initMaze() {
            maze = [];
            for (let i = 0; i < rows; i++) {
                maze[i] = [];
                for (let j = 0; j < cols; j++) {
                    // 1 表示墙, 0 表示路径
                    maze[i][j] = 1;
                }
            }
        }
        
        /**
         * 根据屏幕大小调整画布尺寸
         */
        function adjustCanvasSize() {
            if (isMobileDevice()) {
                // 在移动设备上，根据屏幕尺寸设置画布大小
                const maxWidth = Math.min(window.innerWidth - 40, 500);
                canvas.width = maxWidth;
                canvas.height = maxWidth;
                
                // 根据画布大小动态调整单元格大小，确保至少有15x15的迷宫
                cellSize = Math.max(15, Math.min(25, Math.floor(maxWidth / 20)));
            } else {
                // 在PC上保持原始大小和单元格大小
                canvas.width = 500;
                canvas.height = 500;
                cellSize = 20;
            }
            
            // 更新行列数
            rows = Math.floor(canvas.height / cellSize);
            cols = Math.floor(canvas.width / cellSize);
            
            // 更新玩家大小
            playerSize = Math.max(10, cellSize - 2);
        }
        
        /**
         * 生成迷宫主函数
         * 初始化迷宫，设置入口和出口，生成路径并绘制迷宫
         */
        function generateMaze() {
            // 调整画布大小以适应不同设备
            adjustCanvasSize();
            
            // 清除之前的敌人移动定时器
            if (enemyMoveInterval) {
                clearInterval(enemyMoveInterval);
            }
            
            // 初始化迷宫
            initMaze();
            
            // 设置入口位置 (第一行第二个格子)
            const startRow = 0;
            const startCol = 1;
            maze[startRow][startCol] = 0;
            
            // 设置出口位置 (最后行倒数第二个格子)
            const endRow = rows - 2;
            const endCol = cols - 2;
            maze[endRow][endCol] = 0;
            
            // 从入口开始生成迷宫路径
            carvePath(startRow, startCol);
            
            // 查找所有死角位置用于生成敌人
            findDeadEnds();
            
            // 重置玩家位置到起点
            resetPlayer();
            
            // 重置玩家移动计数器
            playerMoveCount = 0;
            
            // 绘制迷宫图形
            drawMaze();
            
            // 标记入口和出口
            markStartEnd();
            
            // 绘制玩家、敌人和炸弹
            drawPlayer();
            drawEnemies();
            drawBombs();
            
            // 设置敌人每秒移动一次，并在移动后重新绘制整个场景
            enemyMoveInterval = setInterval(() => {
                moveEnemies();
                drawMaze();
                markStartEnd();
                drawPlayer();
                drawEnemies();
                drawBombs();
                handleBombExplosions();
            }, 1000);
        }
        
        /**
         * 查找迷宫中的所有死角位置，并在其中随机生成敌人
         */
        function findDeadEnds() {
            // 清空敌人数组
            enemies = [];
            
            // 遍历迷宫查找死角
            const deadEnds = [];
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    // 检查当前位置是否为路径
                    if (maze[row][col] === 0) {
                        // 计算四个方向上的开放路径数量
                        let openPaths = 0;
                        // 上
                        if (row > 0 && maze[row - 1][col] === 0) openPaths++;
                        // 下
                        if (row < rows - 1 && maze[row + 1][col] === 0) openPaths++;
                        // 左
                        if (col > 0 && maze[row][col - 1] === 0) openPaths++;
                        // 右
                        if (col < cols - 1 && maze[row][col + 1] === 0) openPaths++;
                        
                        // 如果只有一个开放方向，则为死角
                        if (openPaths === 1) {
                            deadEnds.push({row, col});
                        }
                    }
                }
            }
            
            // 在死角中随机选择位置生成敌人（最多生成20个敌人）
            const numEnemies = Math.min(20, deadEnds.length);
            for (let i = 0; i < numEnemies; i++) {
                const randomIndex = Math.floor(Math.random() * deadEnds.length);
                const {row, col} = deadEnds[randomIndex];
                // 确保敌人不生成在入口或出口
                if (!((row === 0 && col === 1) || (row === rows - 2 && col === cols - 2))) {
                    enemies.push({
                        row: row,
                        col: col
                    });
                }
                // 从数组中移除已选择的位置
                deadEnds.splice(randomIndex, 1);
            }
        }
        
        /**
         * 重置玩家位置到起点
         */
        function resetPlayer() {
            player.row = startPosition.row;
            player.col = startPosition.col;
            player.x = player.col * cellSize + (cellSize - playerSize) / 2;
            player.y = player.row * cellSize + (cellSize - playerSize) / 2;
        }
        
        /**
         * 使用深度优先算法递归生成迷宫路径
         * @param {number} row - 当前单元格行号
         * @param {number} col - 当前单元格列号
         */
        function carvePath(row, col) {
            // 定义四个可能的移动方向：上、右、下、左
            const directions = [
                [-2, 0],  // 上
                [0, 2],   // 右
                [2, 0],   // 下
                [0, -2]   // 左
            ];
            
            // 随机打乱方向顺序，使迷宫更加随机
            shuffleArray(directions);
            
            // 尝试向每个方向移动
            for (let [deltaRow, deltaCol] of directions) {
                const newRow = row + deltaRow;
                const newCol = col + deltaCol;
                
                // 检查目标单元格是否在边界内且未被访问过（仍为墙体）
                if (newRow > 0 && newRow < rows - 1 && 
                    newCol > 0 && newCol < cols - 1 && 
                    maze[newRow][newCol] === 1) {
                    
                    // 打通当前单元格和目标单元格之间的墙
                    maze[newRow][newCol] = 0;
                    maze[row + deltaRow / 2][col + deltaCol / 2] = 0;
                    
                    // 递归调用，继续从新单元格挖掘路径
                    carvePath(newRow, newCol);
                }
            }
        }
        
        /**
         * 随机打乱数组元素顺序（Fisher-Yates 算法）
         * @param {Array} array - 需要打乱的数组
         */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                // 随机选择一个元素
                const j = Math.floor(Math.random() * (i + 1));
                // 交换元素位置
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        /**
         * 绘制迷宫到画布上
         */
        function drawMaze() {
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制墙体（黑色方块）
            ctx.fillStyle = 'black';
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    if (maze[row][col] === 1) {
                        ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
                    }
                }
            }
            
            // 绘制网格线（黑色直线）
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            
            // 绘制垂直线
            for (let x = 0; x <= canvas.width; x += cellSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // 绘制水平线
            for (let y = 0; y <= canvas.height; y += cellSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }
        
        /**
         * 绘制玩家方块
         */
        function drawPlayer() {
            // 计算玩家在画布上的实际坐标（居中于所在格子）
            player.x = player.col * cellSize + (cellSize - playerSize) / 2;
            player.y = player.row * cellSize + (cellSize - playerSize) / 2;
            
            // 绘制蓝色玩家方块
            ctx.fillStyle = 'blue';
            ctx.fillRect(player.x, player.y, playerSize, playerSize);
        }
        
        /**
         * 绘制所有敌人
         */
        function drawEnemies() {
            // 敌人大小与玩家相同
            const enemySize = playerSize;
            
            // 绘制每个红色敌人
            ctx.fillStyle = 'red';
            for (let enemy of enemies) {
                const x = enemy.col * cellSize + (cellSize - enemySize) / 2;
                const y = enemy.row * cellSize + (cellSize - enemySize) / 2;
                ctx.fillRect(x, y, enemySize, enemySize);
            }
        }
        
        /**
         * 绘制所有炸弹
         */
        function drawBombs() {
            ctx.fillStyle = 'black';
            for (let bomb of bombs) {
                const bombSize = Math.max(6, playerSize / 2);
                const x = bomb.col * cellSize + (cellSize - bombSize) / 2;
                const y = bomb.row * cellSize + (cellSize - bombSize) / 2;
                ctx.fillRect(x, y, bombSize, bombSize);
            }
        }
        
        /**
         * 在指定位置放置炸弹
         */
        function placeBomb() {
            // 检查是否已经在该位置放置了炸弹
            for (let bomb of bombs) {
                if (bomb.row === player.row && bomb.col === player.col) {
                    return; // 如果已经有一个炸弹在该位置，则不放置新炸弹
                }
            }
            
            // 添加新炸弹
            const bomb = {
                row: player.row,
                col: player.col,
                timer: 7 // 7秒后爆炸
            };
            bombs.push(bomb);
            drawBombs();
        }
        
        /**
         * 处理炸弹爆炸
         */
        function handleBombExplosions() {
            for (let i = bombs.length - 1; i >= 0; i--) {
                bombs[i].timer -= 1;
                
                if (bombs[i].timer <= 0) {
                    // 炸弹爆炸
                    const bombRow = bombs[i].row;
                    const bombCol = bombs[i].col;
                    
                    // 移除爆炸的炸弹
                    bombs.splice(i, 1);
                    
                    // 处理爆炸效果
                    explode(bombRow, bombCol);
                }
            }
        }
        
        /**
         * 爆炸效果处理
         */
        function explode(bombRow, bombCol) {
            // 创建爆炸范围内的坐标列表
            const explosionArea = [];
            
            // 向上
            for (let i = 1; i <= 4; i++) {
                const row = bombRow - i;
                const col = bombCol;
                if (row < 0 || maze[row][col] === 1) break; // 遇到墙体停止
                explosionArea.push({row, col});
            }
            
            // 向下
            for (let i = 1; i <= 4; i++) {
                const row = bombRow + i;
                const col = bombCol;
                if (row >= rows || maze[row][col] === 1) break; // 遇到墙体停止
                explosionArea.push({row, col});
            }
            
            // 向左
            for (let i = 1; i <= 4; i++) {
                const row = bombRow;
                const col = bombCol - i;
                if (col < 0 || maze[row][col] === 1) break; // 遇到墙体停止
                explosionArea.push({row, col});
            }
            
            // 向右
            for (let i = 1; i <= 4; i++) {
                const row = bombRow;
                const col = bombCol + i;
                if (col >= cols || maze[row][col] === 1) break; // 遇到墙体停止
                explosionArea.push({row, col});
            }
            
            // 添加炸弹所在位置
            explosionArea.push({row: bombRow, col: bombCol});
            
            // 绘制爆炸效果
            ctx.fillStyle = 'orange';
            for (let pos of explosionArea) {
                ctx.fillRect(pos.col * cellSize, pos.row * cellSize, cellSize, cellSize);
            }
            
            // 检查是否有敌人在爆炸范围内
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                for (let pos of explosionArea) {
                    if (enemy.row === pos.row && enemy.col === pos.col) {
                        // 移除被炸到的敌人
                        enemies.splice(i, 1);
                        break;
                    }
                }
            }
            
            // 检查玩家是否在爆炸范围内
            for (let pos of explosionArea) {
                if (player.row === pos.row && player.col === pos.col) {
                    // 玩家被炸到，重置位置
                    resetPlayer();
                    break;
                }
            }
            
            // 短暂显示爆炸效果后重新绘制场景
            setTimeout(() => {
                drawMaze();
                markStartEnd();
                drawPlayer();
                drawEnemies();
                drawBombs();
            }, 300);
        }
        
        /**
         * 标记迷宫的入口和出口
         */
        function markStartEnd() {
            // 入口 - 绿色方块
            ctx.fillStyle = 'green';
            ctx.fillRect(1 * cellSize, 0 * cellSize, cellSize, cellSize);
            
            // 出口 - 红色方块
            ctx.fillStyle = 'red';
            ctx.fillRect((cols - 2) * cellSize, (rows - 2) * cellSize, cellSize, cellSize);
        }
        
        /**
         * 检查玩家是否与墙体碰撞
         * @param {number} row - 目标行位置
         * @param {number} col - 目标列位置
         * @returns {boolean} 是否发生碰撞
         */
        function checkCollision(row, col) {
            // 检查是否超出边界
            if (row < 0 || row >= rows || col < 0 || col >= cols) {
                return true;
            }
            
            // 检查是否撞到墙体
            return maze[row][col] === 1;
        }
        
        /**
         * 检查玩家是否与敌人碰撞
         * @returns {boolean} 是否与敌人碰撞
         */
        function checkEnemyCollision() {
            for (let enemy of enemies) {
                if (player.row === enemy.row && player.col === enemy.col) {
                    return true;
                }
            }
            return false;
        }
        
        /**
         * 检查玩家是否到达出口
         * @returns {boolean} 是否到达出口
         */
        function checkWin() {
            // 出口位置在倒数第二行，倒数第二列（与迷宫生成和标记位置一致）
            return player.row === rows - 2 && player.col === cols - 2;
        }
        
        /**
         * 显示过关提示
         */
        function showWinMessage() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(canvas.width/2 - 100, canvas.height/2 - 30, 200, 60);
            
            ctx.font = '20px Arial';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.fillText('恭喜过关!3秒后随机生成新迷宫', canvas.width/2, canvas.height/2 + 10);
        }
        
        /**
         * 移动所有敌人
         */
        function moveEnemies() {
            for (let enemy of enemies) {
                // 获取可能的移动方向
                const possibleMoves = [];
                
                // 上
                if (enemy.row > 0 && maze[enemy.row - 1][enemy.col] === 0) {
                    possibleMoves.push({row: -1, col: 0});
                }
                // 下
                if (enemy.row < rows - 1 && maze[enemy.row + 1][enemy.col] === 0) {
                    possibleMoves.push({row: 1, col: 0});
                }
                // 左
                if (enemy.col > 0 && maze[enemy.row][enemy.col - 1] === 0) {
                    possibleMoves.push({row: 0, col: -1});
                }
                // 右
                if (enemy.col < cols - 1 && maze[enemy.row][enemy.col + 1] === 0) {
                    possibleMoves.push({row: 0, col: 1});
                }
                
                // 如果有可移动方向，则随机选择一个方向移动
                if (possibleMoves.length > 0) {
                    const move = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                    enemy.row += move.row;
                    enemy.col += move.col;
                }
            }
        }
        
        /**
         * 处理键盘按键事件
         * @param {KeyboardEvent} event - 键盘事件对象
         */
        function handleKeyPress(event) {
            let newRow = player.row;
            let newCol = player.col;
            
            // 根据按键确定移动方向
            switch (event.key) {
                case 'ArrowUp':    // 上
                    newRow--;
                    break;
                case 'ArrowDown':  // 下
                    newRow++;
                    break;
                case 'ArrowLeft':  // 左
                    newCol--;
                    break;
                case 'ArrowRight': // 右
                    newCol++;
                    break;
                case 'Control': // Ctrl键放置炸弹
                    placeBomb();
                    return;
                default:
                    return; // 不处理其他按键
            }
            
            // 检查是否发生碰撞
            if (checkCollision(newRow, newCol)) {
                // 碰撞墙体后重置玩家位置到起点
                //resetPlayer();
            } else {
                // 更新玩家位置
                player.row = newRow;
                player.col = newCol;
                
                // 增加玩家移动计数
                playerMoveCount++;
                
                // 注意: 移除了玩家移动时触发敌人移动的代码，因为现在敌人会自动移动
            }
            
            // 检查是否与敌人碰撞
            if (checkEnemyCollision()) {
                // 与敌人碰撞后重置玩家位置到起点
                resetPlayer();
            }
            
            // 检查是否到达出口
            if (checkWin()) {
                // 显示过关提示
                showWinMessage();
                
                // 清除敌人移动定时器
                if (enemyMoveInterval) {
                    clearInterval(enemyMoveInterval);
                    enemyMoveInterval = null;
                }
                
                // 短暂延迟后生成新迷宫
                setTimeout(() => {
                    generateMaze();
                }, 5000);
                return;
            }
            
            // 重新绘制迷宫、玩家和敌人
            drawMaze();
            markStartEnd();
            drawPlayer();
            drawEnemies();
            drawBombs();
            
            // 处理炸弹爆炸
            handleBombExplosions();
        }
        
        /**
         * 处理虚拟方向键点击事件
         * @param {string} direction - 移动方向
         */
        function handleVirtualKeyPress(direction) {
            // 创建一个模拟的键盘事件对象
            const virtualEvent = { key: direction };
            handleKeyPress(virtualEvent);
        }
        
        /**
         * 阻止默认的触摸行为
         * @param {TouchEvent} event - 触摸事件
         */
        function preventTouchDefault(event) {
            event.preventDefault();
        }
        
        // 监听键盘按键事件
        document.addEventListener('keydown', handleKeyPress);
        
        /**
         * 检测是否为移动设备
         * @returns {boolean} 是否为移动设备
         */
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                   (navigator.maxTouchPoints && navigator.maxTouchPoints > 1);
        }
        
        /**
         * 初始化移动端控制按钮
         */
        function initMobileControls() {
            const mobileControls = document.getElementById('mobile-controls');
            if (isMobileDevice()) {
                mobileControls.style.display = 'flex';
            }
        }
        
        // 页面加载完成后自动生成第一个迷宫
        window.onload = function() {
            generateMaze();
            initMobileControls();
            
            // 为移动端控制按钮添加事件监听器
            const upBtn = document.getElementById('up');
            const downBtn = document.getElementById('down');
            const leftBtn = document.getElementById('left');
            const rightBtn = document.getElementById('right');
            const bombBtn = document.getElementById('bomb-btn');
            
            if (upBtn) {
                upBtn.addEventListener('touchstart', function(e) {
                    handleVirtualKeyPress('ArrowUp');
                    e.preventDefault();
                });
            }
            
            if (downBtn) {
                downBtn.addEventListener('touchstart', function(e) {
                    handleVirtualKeyPress('ArrowDown');
                    e.preventDefault();
                });
            }
            
            if (leftBtn) {
                leftBtn.addEventListener('touchstart', function(e) {
                    handleVirtualKeyPress('ArrowLeft');
                    e.preventDefault();
                });
            }
            
            if (rightBtn) {
                rightBtn.addEventListener('touchstart', function(e) {
                    handleVirtualKeyPress('ArrowRight');
                    e.preventDefault();
                });
            }
            
            if (bombBtn) {
                bombBtn.addEventListener('touchstart', function(e) {
                    handleVirtualKeyPress('Control');
                    e.preventDefault();
                });
            }
        };
        
        // 窗口大小改变时重新调整画布
        window.addEventListener('resize', function() {
            if (isMobileDevice()) {
                generateMaze();
            }
        });
    </script>
</body>
</html>