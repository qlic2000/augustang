<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <!-- é¡µé¢å…ƒä¿¡æ¯ -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¿·å®«ç‚¸å¼¹æ¸¸æˆ</title>
    
    <!-- é¡µé¢æ ·å¼ -->
    <style>
        /* é¡µé¢æ•´ä½“å¸ƒå±€æ ·å¼ */
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            touch-action: manipulation; /* é˜²æ­¢è§¦æ‘¸æ—¶çš„é»˜è®¤è¡Œä¸º */
            margin: 0;
            padding: 0;
        }
        
        /* æ ‡é¢˜æ ·å¼ */
        h1 {
            margin: 10px 0;
        }
        
        /* è¿·å®«å®¹å™¨æ ·å¼ */
        #maze-container {
            display: flex;
            justify-content: center;
            margin: 10px;
            width: 100%;
            max-width: 500px;
        }
        
        /* è¿·å®«ç”»å¸ƒæ ·å¼ */
        #mazeCanvas {
            border: 2px solid #333;
            background-color: white;
            width: 100%;
            max-width: 500px;
            aspect-ratio: 1 / 1;
        }
        
        /* æ§åˆ¶æŒ‰é’®å®¹å™¨æ ·å¼ */
        #controls {
            margin: 10px;
        }
        
        /* æŒ‰é’®æ ·å¼ */
        button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        /* æŒ‰é’®æ‚¬åœæ•ˆæœ */
        button:hover {
            background-color: #45a049;
        }
        
        /* æ¸¸æˆè¯´æ˜æ ·å¼ */
        #instructions {
            margin: 10px;
            text-align: center;
            max-width: 500px;
        }
        
        /* ç§»åŠ¨ç«¯æ§åˆ¶æŒ‰é’®å®¹å™¨ */
        #mobile-controls {
            position: fixed;
            bottom: 20px;
            width: 100%;
            display: none;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            pointer-events: none; /* é˜²æ­¢å®¹å™¨æ‹¦æˆªç‚¹å‡»äº‹ä»¶ */
            z-index: 1000; /* ç¡®ä¿æŒ‰é’®åœ¨æœ€ä¸Šå±‚ */
        }
        
        /* æ–¹å‘é”®å®¹å™¨ */
        #d-pad {
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: auto; /* æ¢å¤å­å…ƒç´ çš„ç‚¹å‡»äº‹ä»¶ */
        }
        
        /* æ–¹å‘é”®è¡Œ */
        .d-pad-row {
            display: flex;
        }
        
        /* æ§åˆ¶æŒ‰é’®æ ·å¼ */
        .control-btn {
            width: 60px;
            height: 60px;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 5px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid white;
            border-radius: 10px;
            user-select: none;
            -webkit-user-select: none; /* Safariå…¼å®¹æ€§ */
            cursor: pointer;
            pointer-events: auto; /* ç¡®ä¿æŒ‰é’®èƒ½æ¥æ”¶ç‚¹å‡»äº‹ä»¶ */
            touch-action: manipulation; /* ä¼˜åŒ–è§¦æ‘¸ä½“éªŒ */
        }
        
        /* æ§åˆ¶æŒ‰é’®æŒ‰ä¸‹æ•ˆæœ */
        .control-btn:active {
            background-color: rgba(100, 100, 100, 0.9);
        }
        
        /* ç‚¸å¼¹æŒ‰é’®æ ·å¼ */
        #bomb-btn {
            width: 80px;
            height: 80px;
            font-size: 30px;
            border-radius: 50%;
            pointer-events: auto; /* ç¡®ä¿æŒ‰é’®èƒ½æ¥æ”¶ç‚¹å‡»äº‹ä»¶ */
        }
    </style>
</head>
<body>
    <!-- é¡µé¢æ ‡é¢˜ -->
    <h1>è¿·å®«ç‚¸å¼¹æ¸¸æˆ</h1>
    
    <!-- æ¸¸æˆè¯´æ˜ -->
    <div id="instructions">
        <p>æ–¹å‘é”®ï¼ˆâ†‘ â†“ â† â†’ï¼‰æ§åˆ¶ç§»åŠ¨ï¼Œèº²é¿æ•Œäººï¼ŒCtrlé”®æ”¾ç‚¸å¼¹</p>
    </div>
    
    <!-- è¿·å®«æ˜¾ç¤ºå®¹å™¨ -->
    <div id="maze-container">
        <canvas id="mazeCanvas" width="500" height="500"></canvas>
    </div>
    
    <!-- æ§åˆ¶æŒ‰é’®åŒºåŸŸ -->
    <div id="controls">
        <button onclick="generateMaze()">ç”Ÿæˆæ–°è¿·å®«</button>
    </div>

    <!-- æ·»åŠ å¹³æ¿æ§åˆ¶æŒ‰é’® -->
    <div id="mobile-controls">
        <div id="d-pad">
            <button id="up" class="control-btn">&#8593;</button>
            <div class="d-pad-row">
                <button id="left" class="control-btn">&#8592;</button>
                <button id="right" class="control-btn">&#8594;</button>
            </div>
            <button id="down" class="control-btn">&#8595;</button>
        </div>
        <button id="bomb-btn" class="control-btn">ğŸ’£</button>
    </div>

    <!-- JavaScript è„šæœ¬ -->
    <script>
        // è·å–ç”»å¸ƒå…ƒç´ å’Œç»˜å›¾ä¸Šä¸‹æ–‡
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        
        // è¿·å®«é…ç½®å‚æ•°
        let cellSize = 20;  // æ¯ä¸ªå•å…ƒæ ¼çš„åƒç´ å¤§å°
        let rows, cols;     // è¿·å®«è¡Œåˆ—æ•°ï¼ˆå°†åœ¨adjustCanvasSizeä¸­åˆå§‹åŒ–ï¼‰
        
        // ç©å®¶é…ç½®å‚æ•°
        let playerSize = cellSize - 2; // ç©å®¶æ–¹å—å¤§å°ï¼ˆå°†åœ¨adjustCanvasSizeä¸­åˆå§‹åŒ–ï¼‰
        let player = {
            row: 0,      // ç©å®¶åˆå§‹è¡Œä½ç½®
            col: 1,      // ç©å®¶åˆå§‹åˆ—ä½ç½®
            x: 0,        // ç©å®¶å®é™…xåæ ‡
            y: 0         // ç©å®¶å®é™…yåæ ‡
        };
        
        // æ•Œäººæ•°ç»„
        let enemies = [];
        
        // ç‚¸å¼¹æ•°ç»„
        let bombs = [];
        
        // ç©å®¶ç§»åŠ¨è®¡æ•°å™¨ï¼ˆç”¨äºæ§åˆ¶æ•Œäººç§»åŠ¨é¢‘ç‡ï¼‰
        let playerMoveCount = 0;
        
        // è‡ªåŠ¨ç§»åŠ¨æ•Œäººçš„æ—¶é—´é—´éš”ID
        let enemyMoveInterval = null;
        
        // èµ·ç‚¹ä½ç½®è®°å½•
        const startPosition = {
            row: 0,
            col: 1
        };
        
        // åˆå§‹åŒ–è¿·å®«æ•°ç»„
        let maze = [];
        
        /**
         * åˆå§‹åŒ–è¿·å®«æ•°ç»„
         * åˆ›å»ºä¸€ä¸ªäºŒç»´æ•°ç»„ï¼Œåˆå§‹æ—¶æ‰€æœ‰å•å…ƒæ ¼éƒ½è®¾ç½®ä¸ºå¢™ä½“ï¼ˆå€¼ä¸º1ï¼‰
         */
        function initMaze() {
            maze = [];
            for (let i = 0; i < rows; i++) {
                maze[i] = [];
                for (let j = 0; j < cols; j++) {
                    // 1 è¡¨ç¤ºå¢™, 0 è¡¨ç¤ºè·¯å¾„
                    maze[i][j] = 1;
                }
            }
        }
        
        /**
         * æ ¹æ®å±å¹•å¤§å°è°ƒæ•´ç”»å¸ƒå°ºå¯¸
         */
        function adjustCanvasSize() {
            if (isMobileDevice()) {
                // åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šï¼Œæ ¹æ®å±å¹•å°ºå¯¸è®¾ç½®ç”»å¸ƒå¤§å°
                const maxWidth = Math.min(window.innerWidth - 40, 500);
                canvas.width = maxWidth;
                canvas.height = maxWidth;
                
                // æ ¹æ®ç”»å¸ƒå¤§å°åŠ¨æ€è°ƒæ•´å•å…ƒæ ¼å¤§å°ï¼Œç¡®ä¿è‡³å°‘æœ‰15x15çš„è¿·å®«
                cellSize = Math.max(15, Math.min(25, Math.floor(maxWidth / 20)));
            } else {
                // åœ¨PCä¸Šä¿æŒåŸå§‹å¤§å°å’Œå•å…ƒæ ¼å¤§å°
                canvas.width = 500;
                canvas.height = 500;
                cellSize = 20;
            }
            
            // æ›´æ–°è¡Œåˆ—æ•°
            rows = Math.floor(canvas.height / cellSize);
            cols = Math.floor(canvas.width / cellSize);
            
            // æ›´æ–°ç©å®¶å¤§å°
            playerSize = Math.max(10, cellSize - 2);
        }
        
        /**
         * ç”Ÿæˆè¿·å®«ä¸»å‡½æ•°
         * åˆå§‹åŒ–è¿·å®«ï¼Œè®¾ç½®å…¥å£å’Œå‡ºå£ï¼Œç”Ÿæˆè·¯å¾„å¹¶ç»˜åˆ¶è¿·å®«
         */
        function generateMaze() {
            // è°ƒæ•´ç”»å¸ƒå¤§å°ä»¥é€‚åº”ä¸åŒè®¾å¤‡
            adjustCanvasSize();
            
            // æ¸…é™¤ä¹‹å‰çš„æ•Œäººç§»åŠ¨å®šæ—¶å™¨
            if (enemyMoveInterval) {
                clearInterval(enemyMoveInterval);
            }
            
            // åˆå§‹åŒ–è¿·å®«
            initMaze();
            
            // è®¾ç½®å…¥å£ä½ç½® (ç¬¬ä¸€è¡Œç¬¬äºŒä¸ªæ ¼å­)
            const startRow = 0;
            const startCol = 1;
            maze[startRow][startCol] = 0;
            
            // è®¾ç½®å‡ºå£ä½ç½® (æœ€åè¡Œå€’æ•°ç¬¬äºŒä¸ªæ ¼å­)
            const endRow = rows - 2;
            const endCol = cols - 2;
            maze[endRow][endCol] = 0;
            
            // ä»å…¥å£å¼€å§‹ç”Ÿæˆè¿·å®«è·¯å¾„
            carvePath(startRow, startCol);
            
            // æŸ¥æ‰¾æ‰€æœ‰æ­»è§’ä½ç½®ç”¨äºç”Ÿæˆæ•Œäºº
            findDeadEnds();
            
            // é‡ç½®ç©å®¶ä½ç½®åˆ°èµ·ç‚¹
            resetPlayer();
            
            // é‡ç½®ç©å®¶ç§»åŠ¨è®¡æ•°å™¨
            playerMoveCount = 0;
            
            // ç»˜åˆ¶è¿·å®«å›¾å½¢
            drawMaze();
            
            // æ ‡è®°å…¥å£å’Œå‡ºå£
            markStartEnd();
            
            // ç»˜åˆ¶ç©å®¶ã€æ•Œäººå’Œç‚¸å¼¹
            drawPlayer();
            drawEnemies();
            drawBombs();
            
            // è®¾ç½®æ•Œäººæ¯ç§’ç§»åŠ¨ä¸€æ¬¡ï¼Œå¹¶åœ¨ç§»åŠ¨åé‡æ–°ç»˜åˆ¶æ•´ä¸ªåœºæ™¯
            enemyMoveInterval = setInterval(() => {
                moveEnemies();
                drawMaze();
                markStartEnd();
                drawPlayer();
                drawEnemies();
                drawBombs();
                handleBombExplosions();
            }, 1000);
        }
        
        /**
         * æŸ¥æ‰¾è¿·å®«ä¸­çš„æ‰€æœ‰æ­»è§’ä½ç½®ï¼Œå¹¶åœ¨å…¶ä¸­éšæœºç”Ÿæˆæ•Œäºº
         */
        function findDeadEnds() {
            // æ¸…ç©ºæ•Œäººæ•°ç»„
            enemies = [];
            
            // éå†è¿·å®«æŸ¥æ‰¾æ­»è§’
            const deadEnds = [];
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    // æ£€æŸ¥å½“å‰ä½ç½®æ˜¯å¦ä¸ºè·¯å¾„
                    if (maze[row][col] === 0) {
                        // è®¡ç®—å››ä¸ªæ–¹å‘ä¸Šçš„å¼€æ”¾è·¯å¾„æ•°é‡
                        let openPaths = 0;
                        // ä¸Š
                        if (row > 0 && maze[row - 1][col] === 0) openPaths++;
                        // ä¸‹
                        if (row < rows - 1 && maze[row + 1][col] === 0) openPaths++;
                        // å·¦
                        if (col > 0 && maze[row][col - 1] === 0) openPaths++;
                        // å³
                        if (col < cols - 1 && maze[row][col + 1] === 0) openPaths++;
                        
                        // å¦‚æœåªæœ‰ä¸€ä¸ªå¼€æ”¾æ–¹å‘ï¼Œåˆ™ä¸ºæ­»è§’
                        if (openPaths === 1) {
                            deadEnds.push({row, col});
                        }
                    }
                }
            }
            
            // åœ¨æ­»è§’ä¸­éšæœºé€‰æ‹©ä½ç½®ç”Ÿæˆæ•Œäººï¼ˆæœ€å¤šç”Ÿæˆ20ä¸ªæ•Œäººï¼‰
            const numEnemies = Math.min(20, deadEnds.length);
            for (let i = 0; i < numEnemies; i++) {
                const randomIndex = Math.floor(Math.random() * deadEnds.length);
                const {row, col} = deadEnds[randomIndex];
                // ç¡®ä¿æ•Œäººä¸ç”Ÿæˆåœ¨å…¥å£æˆ–å‡ºå£
                if (!((row === 0 && col === 1) || (row === rows - 2 && col === cols - 2))) {
                    enemies.push({
                        row: row,
                        col: col
                    });
                }
                // ä»æ•°ç»„ä¸­ç§»é™¤å·²é€‰æ‹©çš„ä½ç½®
                deadEnds.splice(randomIndex, 1);
            }
        }
        
        /**
         * é‡ç½®ç©å®¶ä½ç½®åˆ°èµ·ç‚¹
         */
        function resetPlayer() {
            player.row = startPosition.row;
            player.col = startPosition.col;
            player.x = player.col * cellSize + (cellSize - playerSize) / 2;
            player.y = player.row * cellSize + (cellSize - playerSize) / 2;
        }
        
        /**
         * ä½¿ç”¨æ·±åº¦ä¼˜å…ˆç®—æ³•é€’å½’ç”Ÿæˆè¿·å®«è·¯å¾„
         * @param {number} row - å½“å‰å•å…ƒæ ¼è¡Œå·
         * @param {number} col - å½“å‰å•å…ƒæ ¼åˆ—å·
         */
        function carvePath(row, col) {
            // å®šä¹‰å››ä¸ªå¯èƒ½çš„ç§»åŠ¨æ–¹å‘ï¼šä¸Šã€å³ã€ä¸‹ã€å·¦
            const directions = [
                [-2, 0],  // ä¸Š
                [0, 2],   // å³
                [2, 0],   // ä¸‹
                [0, -2]   // å·¦
            ];
            
            // éšæœºæ‰“ä¹±æ–¹å‘é¡ºåºï¼Œä½¿è¿·å®«æ›´åŠ éšæœº
            shuffleArray(directions);
            
            // å°è¯•å‘æ¯ä¸ªæ–¹å‘ç§»åŠ¨
            for (let [deltaRow, deltaCol] of directions) {
                const newRow = row + deltaRow;
                const newCol = col + deltaCol;
                
                // æ£€æŸ¥ç›®æ ‡å•å…ƒæ ¼æ˜¯å¦åœ¨è¾¹ç•Œå†…ä¸”æœªè¢«è®¿é—®è¿‡ï¼ˆä»ä¸ºå¢™ä½“ï¼‰
                if (newRow > 0 && newRow < rows - 1 && 
                    newCol > 0 && newCol < cols - 1 && 
                    maze[newRow][newCol] === 1) {
                    
                    // æ‰“é€šå½“å‰å•å…ƒæ ¼å’Œç›®æ ‡å•å…ƒæ ¼ä¹‹é—´çš„å¢™
                    maze[newRow][newCol] = 0;
                    maze[row + deltaRow / 2][col + deltaCol / 2] = 0;
                    
                    // é€’å½’è°ƒç”¨ï¼Œç»§ç»­ä»æ–°å•å…ƒæ ¼æŒ–æ˜è·¯å¾„
                    carvePath(newRow, newCol);
                }
            }
        }
        
        /**
         * éšæœºæ‰“ä¹±æ•°ç»„å…ƒç´ é¡ºåºï¼ˆFisher-Yates ç®—æ³•ï¼‰
         * @param {Array} array - éœ€è¦æ‰“ä¹±çš„æ•°ç»„
         */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                // éšæœºé€‰æ‹©ä¸€ä¸ªå…ƒç´ 
                const j = Math.floor(Math.random() * (i + 1));
                // äº¤æ¢å…ƒç´ ä½ç½®
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        /**
         * ç»˜åˆ¶è¿·å®«åˆ°ç”»å¸ƒä¸Š
         */
        function drawMaze() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶å¢™ä½“ï¼ˆé»‘è‰²æ–¹å—ï¼‰
            ctx.fillStyle = 'black';
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    if (maze[row][col] === 1) {
                        ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
                    }
                }
            }
            
            // ç»˜åˆ¶ç½‘æ ¼çº¿ï¼ˆé»‘è‰²ç›´çº¿ï¼‰
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            
            // ç»˜åˆ¶å‚ç›´çº¿
            for (let x = 0; x <= canvas.width; x += cellSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // ç»˜åˆ¶æ°´å¹³çº¿
            for (let y = 0; y <= canvas.height; y += cellSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }
        
        /**
         * ç»˜åˆ¶ç©å®¶æ–¹å—
         */
        function drawPlayer() {
            // è®¡ç®—ç©å®¶åœ¨ç”»å¸ƒä¸Šçš„å®é™…åæ ‡ï¼ˆå±…ä¸­äºæ‰€åœ¨æ ¼å­ï¼‰
            player.x = player.col * cellSize + (cellSize - playerSize) / 2;
            player.y = player.row * cellSize + (cellSize - playerSize) / 2;
            
            // ç»˜åˆ¶è“è‰²ç©å®¶æ–¹å—
            ctx.fillStyle = 'blue';
            ctx.fillRect(player.x, player.y, playerSize, playerSize);
        }
        
        /**
         * ç»˜åˆ¶æ‰€æœ‰æ•Œäºº
         */
        function drawEnemies() {
            // æ•Œäººå¤§å°ä¸ç©å®¶ç›¸åŒ
            const enemySize = playerSize;
            
            // ç»˜åˆ¶æ¯ä¸ªçº¢è‰²æ•Œäºº
            ctx.fillStyle = 'red';
            for (let enemy of enemies) {
                const x = enemy.col * cellSize + (cellSize - enemySize) / 2;
                const y = enemy.row * cellSize + (cellSize - enemySize) / 2;
                ctx.fillRect(x, y, enemySize, enemySize);
            }
        }
        
        /**
         * ç»˜åˆ¶æ‰€æœ‰ç‚¸å¼¹
         */
        function drawBombs() {
            ctx.fillStyle = 'black';
            for (let bomb of bombs) {
                const bombSize = Math.max(6, playerSize / 2);
                const x = bomb.col * cellSize + (cellSize - bombSize) / 2;
                const y = bomb.row * cellSize + (cellSize - bombSize) / 2;
                ctx.fillRect(x, y, bombSize, bombSize);
            }
        }
        
        /**
         * åœ¨æŒ‡å®šä½ç½®æ”¾ç½®ç‚¸å¼¹
         */
        function placeBomb() {
            // æ£€æŸ¥æ˜¯å¦å·²ç»åœ¨è¯¥ä½ç½®æ”¾ç½®äº†ç‚¸å¼¹
            for (let bomb of bombs) {
                if (bomb.row === player.row && bomb.col === player.col) {
                    return; // å¦‚æœå·²ç»æœ‰ä¸€ä¸ªç‚¸å¼¹åœ¨è¯¥ä½ç½®ï¼Œåˆ™ä¸æ”¾ç½®æ–°ç‚¸å¼¹
                }
            }
            
            // æ·»åŠ æ–°ç‚¸å¼¹
            const bomb = {
                row: player.row,
                col: player.col,
                timer: 7 // 7ç§’åçˆ†ç‚¸
            };
            bombs.push(bomb);
            drawBombs();
        }
        
        /**
         * å¤„ç†ç‚¸å¼¹çˆ†ç‚¸
         */
        function handleBombExplosions() {
            for (let i = bombs.length - 1; i >= 0; i--) {
                bombs[i].timer -= 1;
                
                if (bombs[i].timer <= 0) {
                    // ç‚¸å¼¹çˆ†ç‚¸
                    const bombRow = bombs[i].row;
                    const bombCol = bombs[i].col;
                    
                    // ç§»é™¤çˆ†ç‚¸çš„ç‚¸å¼¹
                    bombs.splice(i, 1);
                    
                    // å¤„ç†çˆ†ç‚¸æ•ˆæœ
                    explode(bombRow, bombCol);
                }
            }
        }
        
        /**
         * çˆ†ç‚¸æ•ˆæœå¤„ç†
         */
        function explode(bombRow, bombCol) {
            // åˆ›å»ºçˆ†ç‚¸èŒƒå›´å†…çš„åæ ‡åˆ—è¡¨
            const explosionArea = [];
            
            // å‘ä¸Š
            for (let i = 1; i <= 4; i++) {
                const row = bombRow - i;
                const col = bombCol;
                if (row < 0 || maze[row][col] === 1) break; // é‡åˆ°å¢™ä½“åœæ­¢
                explosionArea.push({row, col});
            }
            
            // å‘ä¸‹
            for (let i = 1; i <= 4; i++) {
                const row = bombRow + i;
                const col = bombCol;
                if (row >= rows || maze[row][col] === 1) break; // é‡åˆ°å¢™ä½“åœæ­¢
                explosionArea.push({row, col});
            }
            
            // å‘å·¦
            for (let i = 1; i <= 4; i++) {
                const row = bombRow;
                const col = bombCol - i;
                if (col < 0 || maze[row][col] === 1) break; // é‡åˆ°å¢™ä½“åœæ­¢
                explosionArea.push({row, col});
            }
            
            // å‘å³
            for (let i = 1; i <= 4; i++) {
                const row = bombRow;
                const col = bombCol + i;
                if (col >= cols || maze[row][col] === 1) break; // é‡åˆ°å¢™ä½“åœæ­¢
                explosionArea.push({row, col});
            }
            
            // æ·»åŠ ç‚¸å¼¹æ‰€åœ¨ä½ç½®
            explosionArea.push({row: bombRow, col: bombCol});
            
            // ç»˜åˆ¶çˆ†ç‚¸æ•ˆæœ
            ctx.fillStyle = 'orange';
            for (let pos of explosionArea) {
                ctx.fillRect(pos.col * cellSize, pos.row * cellSize, cellSize, cellSize);
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰æ•Œäººåœ¨çˆ†ç‚¸èŒƒå›´å†…
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                for (let pos of explosionArea) {
                    if (enemy.row === pos.row && enemy.col === pos.col) {
                        // ç§»é™¤è¢«ç‚¸åˆ°çš„æ•Œäºº
                        enemies.splice(i, 1);
                        break;
                    }
                }
            }
            
            // æ£€æŸ¥ç©å®¶æ˜¯å¦åœ¨çˆ†ç‚¸èŒƒå›´å†…
            for (let pos of explosionArea) {
                if (player.row === pos.row && player.col === pos.col) {
                    // ç©å®¶è¢«ç‚¸åˆ°ï¼Œé‡ç½®ä½ç½®
                    resetPlayer();
                    break;
                }
            }
            
            // çŸ­æš‚æ˜¾ç¤ºçˆ†ç‚¸æ•ˆæœåé‡æ–°ç»˜åˆ¶åœºæ™¯
            setTimeout(() => {
                drawMaze();
                markStartEnd();
                drawPlayer();
                drawEnemies();
                drawBombs();
            }, 300);
        }
        
        /**
         * æ ‡è®°è¿·å®«çš„å…¥å£å’Œå‡ºå£
         */
        function markStartEnd() {
            // å…¥å£ - ç»¿è‰²æ–¹å—
            ctx.fillStyle = 'green';
            ctx.fillRect(1 * cellSize, 0 * cellSize, cellSize, cellSize);
            
            // å‡ºå£ - çº¢è‰²æ–¹å—
            ctx.fillStyle = 'red';
            ctx.fillRect((cols - 2) * cellSize, (rows - 2) * cellSize, cellSize, cellSize);
        }
        
        /**
         * æ£€æŸ¥ç©å®¶æ˜¯å¦ä¸å¢™ä½“ç¢°æ’
         * @param {number} row - ç›®æ ‡è¡Œä½ç½®
         * @param {number} col - ç›®æ ‡åˆ—ä½ç½®
         * @returns {boolean} æ˜¯å¦å‘ç”Ÿç¢°æ’
         */
        function checkCollision(row, col) {
            // æ£€æŸ¥æ˜¯å¦è¶…å‡ºè¾¹ç•Œ
            if (row < 0 || row >= rows || col < 0 || col >= cols) {
                return true;
            }
            
            // æ£€æŸ¥æ˜¯å¦æ’åˆ°å¢™ä½“
            return maze[row][col] === 1;
        }
        
        /**
         * æ£€æŸ¥ç©å®¶æ˜¯å¦ä¸æ•Œäººç¢°æ’
         * @returns {boolean} æ˜¯å¦ä¸æ•Œäººç¢°æ’
         */
        function checkEnemyCollision() {
            for (let enemy of enemies) {
                if (player.row === enemy.row && player.col === enemy.col) {
                    return true;
                }
            }
            return false;
        }
        
        /**
         * æ£€æŸ¥ç©å®¶æ˜¯å¦åˆ°è¾¾å‡ºå£
         * @returns {boolean} æ˜¯å¦åˆ°è¾¾å‡ºå£
         */
        function checkWin() {
            // å‡ºå£ä½ç½®åœ¨å€’æ•°ç¬¬äºŒè¡Œï¼Œå€’æ•°ç¬¬äºŒåˆ—ï¼ˆä¸è¿·å®«ç”Ÿæˆå’Œæ ‡è®°ä½ç½®ä¸€è‡´ï¼‰
            return player.row === rows - 2 && player.col === cols - 2;
        }
        
        /**
         * æ˜¾ç¤ºè¿‡å…³æç¤º
         */
        function showWinMessage() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(canvas.width/2 - 100, canvas.height/2 - 30, 200, 60);
            
            ctx.font = '20px Arial';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.fillText('æ­å–œè¿‡å…³!3ç§’åéšæœºç”Ÿæˆæ–°è¿·å®«', canvas.width/2, canvas.height/2 + 10);
        }
        
        /**
         * ç§»åŠ¨æ‰€æœ‰æ•Œäºº
         */
        function moveEnemies() {
            for (let enemy of enemies) {
                // è·å–å¯èƒ½çš„ç§»åŠ¨æ–¹å‘
                const possibleMoves = [];
                
                // ä¸Š
                if (enemy.row > 0 && maze[enemy.row - 1][enemy.col] === 0) {
                    possibleMoves.push({row: -1, col: 0});
                }
                // ä¸‹
                if (enemy.row < rows - 1 && maze[enemy.row + 1][enemy.col] === 0) {
                    possibleMoves.push({row: 1, col: 0});
                }
                // å·¦
                if (enemy.col > 0 && maze[enemy.row][enemy.col - 1] === 0) {
                    possibleMoves.push({row: 0, col: -1});
                }
                // å³
                if (enemy.col < cols - 1 && maze[enemy.row][enemy.col + 1] === 0) {
                    possibleMoves.push({row: 0, col: 1});
                }
                
                // å¦‚æœæœ‰å¯ç§»åŠ¨æ–¹å‘ï¼Œåˆ™éšæœºé€‰æ‹©ä¸€ä¸ªæ–¹å‘ç§»åŠ¨
                if (possibleMoves.length > 0) {
                    const move = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                    enemy.row += move.row;
                    enemy.col += move.col;
                }
            }
        }
        
        /**
         * å¤„ç†é”®ç›˜æŒ‰é”®äº‹ä»¶
         * @param {KeyboardEvent} event - é”®ç›˜äº‹ä»¶å¯¹è±¡
         */
        function handleKeyPress(event) {
            let newRow = player.row;
            let newCol = player.col;
            
            // æ ¹æ®æŒ‰é”®ç¡®å®šç§»åŠ¨æ–¹å‘
            switch (event.key) {
                case 'ArrowUp':    // ä¸Š
                    newRow--;
                    break;
                case 'ArrowDown':  // ä¸‹
                    newRow++;
                    break;
                case 'ArrowLeft':  // å·¦
                    newCol--;
                    break;
                case 'ArrowRight': // å³
                    newCol++;
                    break;
                case 'Control': // Ctrlé”®æ”¾ç½®ç‚¸å¼¹
                    placeBomb();
                    return;
                default:
                    return; // ä¸å¤„ç†å…¶ä»–æŒ‰é”®
            }
            
            // æ£€æŸ¥æ˜¯å¦å‘ç”Ÿç¢°æ’
            if (checkCollision(newRow, newCol)) {
                // ç¢°æ’å¢™ä½“åé‡ç½®ç©å®¶ä½ç½®åˆ°èµ·ç‚¹
                //resetPlayer();
            } else {
                // æ›´æ–°ç©å®¶ä½ç½®
                player.row = newRow;
                player.col = newCol;
                
                // å¢åŠ ç©å®¶ç§»åŠ¨è®¡æ•°
                playerMoveCount++;
                
                // æ³¨æ„: ç§»é™¤äº†ç©å®¶ç§»åŠ¨æ—¶è§¦å‘æ•Œäººç§»åŠ¨çš„ä»£ç ï¼Œå› ä¸ºç°åœ¨æ•Œäººä¼šè‡ªåŠ¨ç§»åŠ¨
            }
            
            // æ£€æŸ¥æ˜¯å¦ä¸æ•Œäººç¢°æ’
            if (checkEnemyCollision()) {
                // ä¸æ•Œäººç¢°æ’åé‡ç½®ç©å®¶ä½ç½®åˆ°èµ·ç‚¹
                resetPlayer();
            }
            
            // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾å‡ºå£
            if (checkWin()) {
                // æ˜¾ç¤ºè¿‡å…³æç¤º
                showWinMessage();
                
                // æ¸…é™¤æ•Œäººç§»åŠ¨å®šæ—¶å™¨
                if (enemyMoveInterval) {
                    clearInterval(enemyMoveInterval);
                    enemyMoveInterval = null;
                }
                
                // çŸ­æš‚å»¶è¿Ÿåç”Ÿæˆæ–°è¿·å®«
                setTimeout(() => {
                    generateMaze();
                }, 5000);
                return;
            }
            
            // é‡æ–°ç»˜åˆ¶è¿·å®«ã€ç©å®¶å’Œæ•Œäºº
            drawMaze();
            markStartEnd();
            drawPlayer();
            drawEnemies();
            drawBombs();
            
            // å¤„ç†ç‚¸å¼¹çˆ†ç‚¸
            handleBombExplosions();
        }
        
        /**
         * å¤„ç†è™šæ‹Ÿæ–¹å‘é”®ç‚¹å‡»äº‹ä»¶
         * @param {string} direction - ç§»åŠ¨æ–¹å‘
         */
        function handleVirtualKeyPress(direction) {
            // åˆ›å»ºä¸€ä¸ªæ¨¡æ‹Ÿçš„é”®ç›˜äº‹ä»¶å¯¹è±¡
            const virtualEvent = { key: direction };
            handleKeyPress(virtualEvent);
        }
        
        /**
         * é˜»æ­¢é»˜è®¤çš„è§¦æ‘¸è¡Œä¸º
         * @param {TouchEvent} event - è§¦æ‘¸äº‹ä»¶
         */
        function preventTouchDefault(event) {
            event.preventDefault();
        }
        
        // ç›‘å¬é”®ç›˜æŒ‰é”®äº‹ä»¶
        document.addEventListener('keydown', handleKeyPress);
        
        /**
         * æ£€æµ‹æ˜¯å¦ä¸ºç§»åŠ¨è®¾å¤‡
         * @returns {boolean} æ˜¯å¦ä¸ºç§»åŠ¨è®¾å¤‡
         */
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                   (navigator.maxTouchPoints && navigator.maxTouchPoints > 1);
        }
        
        /**
         * åˆå§‹åŒ–ç§»åŠ¨ç«¯æ§åˆ¶æŒ‰é’®
         */
        function initMobileControls() {
            const mobileControls = document.getElementById('mobile-controls');
            if (isMobileDevice()) {
                mobileControls.style.display = 'flex';
            }
        }
        
        // é¡µé¢åŠ è½½å®Œæˆåè‡ªåŠ¨ç”Ÿæˆç¬¬ä¸€ä¸ªè¿·å®«
        window.onload = function() {
            generateMaze();
            initMobileControls();
            
            // ä¸ºç§»åŠ¨ç«¯æ§åˆ¶æŒ‰é’®æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
            const upBtn = document.getElementById('up');
            const downBtn = document.getElementById('down');
            const leftBtn = document.getElementById('left');
            const rightBtn = document.getElementById('right');
            const bombBtn = document.getElementById('bomb-btn');
            
            if (upBtn) {
                upBtn.addEventListener('touchstart', function(e) {
                    handleVirtualKeyPress('ArrowUp');
                    e.preventDefault();
                });
            }
            
            if (downBtn) {
                downBtn.addEventListener('touchstart', function(e) {
                    handleVirtualKeyPress('ArrowDown');
                    e.preventDefault();
                });
            }
            
            if (leftBtn) {
                leftBtn.addEventListener('touchstart', function(e) {
                    handleVirtualKeyPress('ArrowLeft');
                    e.preventDefault();
                });
            }
            
            if (rightBtn) {
                rightBtn.addEventListener('touchstart', function(e) {
                    handleVirtualKeyPress('ArrowRight');
                    e.preventDefault();
                });
            }
            
            if (bombBtn) {
                bombBtn.addEventListener('touchstart', function(e) {
                    handleVirtualKeyPress('Control');
                    e.preventDefault();
                });
            }
        };
        
        // çª—å£å¤§å°æ”¹å˜æ—¶é‡æ–°è°ƒæ•´ç”»å¸ƒ
        window.addEventListener('resize', function() {
            if (isMobileDevice()) {
                generateMaze();
            }
        });
    </script>
</body>
</html>